<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="Cache-control" content="public">
	<title>Dem particles</title>
	<link rel="stylesheet" href="css/style.css" />
</head>

<style type="text/css">
	body {
		width: 100%;
		height: 100%;
		overflow: hidden;
		overflow-y: hidden;
		margin: 0;
		padding: 0;
		background: hsl(180, 10%, 10%);
	}

	* {
		touch-action: none;
	}

	CANVAS {
		transform: translate3d(0, 0, 0);
		position: absolute;
		top: 0;
	}
</style>

<body>

	<script>
		let particles = {
			settings: {
				density: 1000,
				startingX: 0,
				startingY: 0
			},

			particles: {},
			particleIndex: 0,

			init: function() {
				// Create canvas
				this.canvas = document.createElement("canvas");
				document.body.appendChild(this.canvas);
				this.ctx = this.canvas.getContext("2d");
				this.canvas.style.background = "transparent";

				this.canvas.width = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
				this.canvas.height = Math.min(document.documentElement.clientHeight, window.innerHeight || 0);

				// Create canvas for that contains the sand piles :)
				this.stackingCanvas = this.canvas.cloneNode(false);
				document.body.appendChild(this.stackingCanvas);
				this.stackingCanvas.ctx = this.stackingCanvas.getContext("2d");

				// Create array to contain height for each pixel row
				this.pileHeight = new Array(this.canvas.width);
				this.pileHeight.fill(0);
				window.pileHeight = this.pileHeight;

				this.settings.startingX = this.canvas.width / 2;
				this.settings.startingY = this.canvas.height / 2;

				this.r = Math.round(Math.random() * 32);
				this.g = Math.round(Math.random() * 32);
				this.b = Math.round(Math.random() * 255);


				let updateCenterPoint = function(evt) {
					evt.preventDefault();
					let temp = evt;
					if (evt.touches && evt.touches.length) {
						temp = evt.touches[0];
					}
					if (temp.clientY + window.scrollY > this.canvas.height) {
						return;
					}
					this.settings.startingX = temp.clientX;
					this.settings.startingY = temp.clientY + window.scrollY;
				};

				window.addEventListener('mousemove', updateCenterPoint.bind(this), false);

				window.addEventListener('mousedown', function() {
					this.mouseDown = true
				}.bind(this), false)
				window.addEventListener('mouseup', function() {
					this.mouseDown = false
				}.bind(this), false)

				window.addEventListener('touchmove', updateCenterPoint.bind(this), false)
				window.addEventListener('touchstart', function(e) {
					e.preventDefault();
					this.mouseDown = true
				}.bind(this), false)
				window.addEventListener('touchend', function() {
					this.mouseDown = false
				}.bind(this), false)

				window.addEventListener('keypress', function() {
					this.r = Math.round(Math.random() * 32);
					this.g = Math.round(Math.random() * 32	);
					this.b = Math.round(Math.random() * 255);

				}.bind(this), false)

				this.animate();
			},

			particle: function(params) {
				// Establish starting positions and velocities
				this.x = params.mother.settings.startingX;
				this.y = params.mother.settings.startingY;
				this.xs = params.mother.settings.startingX;
				this.ys = params.mother.settings.startingY;

				this.color = params.color;

				// Determine original X-axis speed based on setting limitation
				this.vx = -2 + Math.random() * 4;
				this.vy = -2 + Math.random() * 4;

				// Add new particle to the index
				// Object used as it's simpler to manage that an array
				params.mother.particleIndex++;
				params.mother.particles[params.mother.particleIndex] = this;
				this.id = params.mother.particleIndex;
				this.gravity = 0.8;


				this.setPixel = function(trgt, x, y, c) {
					var p = trgt.createImageData(1, 1);
					p.data[0] = c.r;
					p.data[1] = c.g;
					p.data[2] = c.b;
					p.data[3] = 255;
					trgt.putImageData(p, x, y);
				}

				this.draw = function(params) {
					let thisX = Math.round(this.x);

// Delete particles that are offscreen
					if (this.ys > params.mother.canvas.height - params.mother.pileHeight[thisX] ||
						this.xs < 0 ||
						this.xs > params.mother.canvas.width) {
						delete params.mother.particles[this.id];
						return;
					}
//
					if (this.y < params.mother.canvas.height - params.mother.pileHeight[thisX]) {
						this.x += this.vx;
						this.y += this.vy;

						// Adjust for gravity
						this.vy += this.gravity;
						this.setPixel(params.mother.ctx, this.x, this.y, {
							r: this.color.r,
							g: this.color.g,
							b: this.color.b
						});
						return;
					}

// Start piling from the bottom of the canvas
					if (this.y >= params.mother.canvas.height - params.mother.pileHeight[thisX]) {
						this.y = params.mother.canvas.height - params.mother.pileHeight[thisX] - 1;
					}

// Current Y position of the particle
					let thisCurrentY = params.mother.canvas.height - this.y;

					let thisXl = params.mother.pileHeight[thisX - 1];
					let thisXr = params.mother.pileHeight[thisX + 1];

// Check if particles are overflowin x axis
					if(thisX < 1) {thisXl = params.mother.pileHeight[thisX]}
					if(thisX > params.mother.canvas.width-2) {thisXr = params.mother.pileHeight[thisX]}

					if(this.vx <=0) {
						// reset vertical speed to 1.2 so after gravity particle wont move more than one pixel
						if (thisCurrentY > thisXl) {this.vx = -1;}
						else if (thisCurrentY > thisXr) {this.vx = 1;}
						this.vy = 1.2;
					}


					if (this.vx > 0) {
						if(thisCurrentY > thisXr) { this.vx = 1;}
						else if (thisCurrentY > thisXl) {this.vx= -1;}
						this.vy = 1.2;
					}

					if(params.mother.pileHeight[thisX] <= thisXl &&
						params.mother.pileHeight[thisX] <= thisXr) {
						params.mother.pileHeight[thisX] =  params.mother.canvas.height - Math.round(this.y);
						this.setPixel(params.mother.stackingCanvas.ctx, thisX, Math.round(this.y), {
							r: this.color.r,
							g: this.color.g,
							b: this.color.b
						});
					delete params.mother.particles[this.id];
					}
				}

			},

			animate: function() {
				let render = function() {
					this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height)
					for (let i = 0, j = this.settings.density; i < j; i++) {
						if (Math.random() > 0.98 && this.mouseDown === true) {

							new this.particle({
								color: {
									r: this.r,
									g: this.g,
									b: this.b
								},
								mother: this,
							});
						}
					}

					let count = 0;
					for (let i in this.particles) {
						count++;
						this.particles[i].draw({
							mother: this
						});
					}
					document.title = count;
					requestAnimationFrame(render.bind(this))
				};
				requestAnimationFrame(render.bind(this));
			}
		};
		particles.init();
	</script>
</body>

</html>
